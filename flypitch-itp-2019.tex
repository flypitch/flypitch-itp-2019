\documentclass[a4paper,USenglish,cleveref, autoref]{lipics-v2019}
%This is a template for producing LIPIcs articles. 
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling cleveref support, use "autoref"

\usepackage{color}
\definecolor{keywordcolor}{rgb}{0.7, 0.1, 0.1}   % red
\definecolor{tacticcolor}{rgb}{0.1, 0.2, 0.6}    % blue
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}      % green
\definecolor{attributecolor}{rgb}{0.7, 0.1, 0.1} % red
\def\lstlanguagefiles{lstlean.tex}
\lstset{language=lean,breakatwhitespace,xleftmargin=\parindent}
\usepackage{mathabx}

\newcommand{\B}{\mathbb{B}}
\newcommand{\lil}{\lstinline}
\newcommand{\N}{\mathbb{N}}


%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{A formalization of forcing and the consistency of the failure of the continuum hypothesis} %TODO Please add

\titlerunning{A formalization of forcing and the consistency of the failure of the continuum hypothesis}%optional, please use if title is longer than one line

\author{Jesse Michael Han\footnote{Corresponding author.}}{Department of Mathematics, University of Pittsburgh \and \url{https://www.pitt.edu/~jmh288}}{jessemichaelhan@gmail.com}{}{}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional

\author{Floris van Doorn}{Department of Mathematics, University of Pittsburgh}{}{}{}

\authorrunning{J.\,M. Han and F.\, van Doorn}%TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Jesse Michael Han and Floris van Doorn}%TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[100]{}
% \ccsdesc[100]{}%TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 

\keywords{Interactive theorem proving, formal verification, set theory, forcing, independence, continuum hypothesis, Boolean-valued models}%TODO mandatory; please add comma-separated list of keywords

\category{}%optional, e.g. invited paper

\relatedversion{}%optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversion{A full version of the paper is available at \url{...}.}

\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{The authors would like to thank the members of the Pitt-CMU Lean group, particularly Simon Hudon, Jeremy Avigad, Mario Carneiro, and Tom Hales for their feedback and suggestions; we are also grateful to Dana Scott and John Bell for their advice and correspondence.}%optional

%\nolinenumbers %uncomment to disable line numbering

%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{}
\EventNoEds{2}
\EventLongTitle{}
\EventShortTitle{ITP 2019}
\EventAcronym{ITP}
\EventYear{2019}
\EventDate{}
\EventLocation{}
\EventLogo{}
\SeriesVolume{}
% \ArticleNo{}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
We describe a formalization of forcing using Boolean-valued models in the Lean 3 theorem prover, including the fundamental theorem of forcing and a deep embedding of first-order logic with a Boolean-valued soundness theorem. As an application of our framework, we specialize our construction to a Boolean completion of the Cohen poset and formally verify in the resulting model the failure of the continuum hypothesis.
\end{abstract}

%TODO(jesse) maybe talk a bit more about the grand strategy for formalizing the independence of CH, i.e. all the prerequisites, and move the discussion about BVMs to the proof sketch section.
\section*{Introduction}
The continuum hypothesis states that there are no sets strictly larger than the countable natural numbers and strictly smaller than the uncountable real numbers. It was introduced by Cantor in 1878 and was the very first problem on Hilbert's list of twenty-three outstanding problems in mathematics. G\"odel proved in 1938 \cite{godel1938consistency} that the continuum hypothesis was consistent with $\mathsf{ZFC}$, and later conjectured that the continuum hypothesis was independent of $\mathsf{ZFC}$, i.e. neither provable nor disprovable from the $\mathsf{ZFC}$ axioms. In 1963, Paul Cohen developed \emph{forcing} \cite{cohen-the-independence-of-the-continuum-hypothesis-1}, which allowed him to prove the consistency of the negation of the continuum hypothesis, and therefore complete the independence proof. For this work, which marked the beginning of modern set theory, he was awarded a Fields medal---the only one to ever be awarded for a work in mathematical logic.

The work we describe in this paper is part of the Flypitch project\footnote{\url{https://github.com/flypitch/flypitch/}}, which aims to formalize the independence of the continuum hypothesis. Our results mark a major milestone towards that goal.

Our formalization is written in the Lean 3 theorem prover. Lean is an interactive proof assistant under active development at Microsoft Research \cite{de2015lean} \cite{sebastian-slides}. It implements the Calculus of Inductive Constructions and has a similar metatheory to Coq, adding definitional proof irrelevance, quotient types, and a noncomputable choice principle. There is a well-known encoding of $\mathsf{ZFC}$ into dependent type theory with CIC, due to Aczel and Werner, which has been implemented in Lean's mathematical components library \lil{mathlib}. The fact that Lean's metatheory is powerful enough to encode a model of $\mathsf{ZFC}$ already allows us to perform metatheoretic arguments about $\mathsf{ZFC}$ which were unavailable to e.g. Paulson \cite{paulson2003relative}, who went to extreme lengths to circumvent them inside Isabelle/ZF. While this was a formidable task, we content ourselves with treating $\mathsf{ZFC}$ as a mathematical object of study, and freely ignore the restrictions which it would impose as a foundation for the metatheory.

Indeed, our formalization makes as much use of the expressiveness of Lean's dependent type theory as possible, using constructions which are impossible or unwieldy to encode in HOL, much less ZF: Lean's ordinals and cardinals, which are defined as equivalence classes of well-ordered types, live one universe level up and play a crucial role in the forcing argument; the models of set theory we construct require as input entire universes of types; our encoding of first-order logic crucially uses parametrized inductive types to equate type-correctness with well-formedness, eliminating the need for separate well-formedness proofs.

Why Boolean-valued models? The method of forcing with Boolean-valued models was developed by Solovay and Scott (and independently, Vop{\v e}nka) in '65-'66 \cite{scott1} \cite{vopenka1} as a simplification of Cohen's method. Some of these simplifications were incorporated by Shoenfield \cite{solovay1} into a general theory of forcing using partial orders, and it is in this form that forcing is usually practiced. While both approaches have essentially the same mathematical content (see e.g. the discussion in Kunen \cite{kunen1} or Jech \cite{jech1}), there are several reasons why we chose Boolean-valued models for our formalization:

\begin{itemize}
\item \textbf{Modularity.} The theory of forcing with Boolean-valued models cleanly splits into several components (a general theory of Boolean-valued semantics for first-order logic, a library for calculations inside complete Boolean algebras, the construction of Boolean-valued models of set theory, and the specifics of the forcing argument itself) which could be formalized in parallel and then recombined.

\item \textbf{Directness.} For the purposes of an independence proof, the Boolean-valued soundness theorem eliminates the need to produce a two-valued model. This approach also bypasses any requirement for the reflection theorem/L\"owenheim-Skolem theorems, Mostowski collapse, countable transitive models, or genericity considerations for filters.

\item \textbf{Novelty and reusability.} As far as we were able to tell, the Boolean-valued approach to forcing has never been formalized. Furthermore, while for the purposes of an independence proof, forcing with Boolean-valued models and forcing with countable transitive models accomplish the same thing, a general library for Boolean-valued semantics of a deeply embedded logic could be used for formal verification applications outside of set theory, e.g. to formalize the Boolean-valued semantics of the stochastic $\lambda$-calculus \cite{scott2}.

  \item \textbf{Amenability to structural induction.} As with Coq, Lean is able to encode extremely complex objects and reason about their specifications using inductive types. However, the user must be careful to choose the encoding so that properties they wish to reason about are accessible by structural induction, which is the most natural mode of reasoning in the proof assistant. After observing (1) that the Aczel-Werner encoding of ZFC as an inductive type is essentially a special case of the recursive \emph{name} construction from forcing (c.f. Section \ref{sect:bvm}), and (2) that the automatically-generated induction principle for that inductive type \emph{is} $\in$-induction, it is easy to see that this encoding can be modified to produce a Boolean-valued model of set theory where, again, $\in$-induction comes for free.
\end{itemize}



%%%%% put at end of introduction
The rest of the paper is organized as follows. In Section \ref{sect:outline} we outline the method of Boolean-valued models and sketch the forcing argument. Section \ref{sect:fol} discusses a deep embedding of first-order logic, including a proof system, soundness and completeness theorems, and crucially Boolean-valued semantics and the Boolean-valued soundness theorem. Section \ref{sect:bvm} discusses our construction of Boolean-valued models of set theory, emphasizing the usefulness of being able to metaprogram custom tactics to simulate predicate calculus inside an arbitrary complete Boolean algebra. Section \ref{sect:forcing} describes the formalization of the forcing argument and the construction of a suitable Boolean algebra for forcing $\neg\mathsf{CH}$. Section \ref{sect:ccc} describes the formalization of the $\Delta$-system lemma, a technical result in transfinite combinatorics which ensures the preservation of cardinal inequalities. We conclude with an indication of future work towards a formal proof of the independence of the continuum hypothesis.
%%%%%
\section{Outline of the proof}
\label{sect:outline}



% A \emph{proof} of $\mathsf{CH}$ from $\mathsf{ZFC}$ is a finite list of deductions starting from $\mathsf{ZFC}$ and ending at $\mathsf{CH}$. We write $\mathsf{ZFC} \vdash \mathsf{CH}$ to indicate that there exists a proof of $\mathsf{CH}$ from $\mathsf{ZFC}$. It is easy to show that $\mathsf{ZFC} \vdash \mathsf{CH}$: one simply exhibits a proof. What is harder is showing that $\mathsf{CH}$ is unprovable: one has to rule out all possible proofs. If one is allowed to use $\mathsf{ZFC} \vdash \neg \mathsf{CH}$, it is easy to show that $\mathsf{CH}$ is unprovable. What is even harder is showing simultaneously that $\mathsf{CH}$ is independent of ZFC: both  $\mathsf{CH}$ \emph{and} $\neg \mathsf{CH}$ are unprovable.

% Separate from provability is satisfiability: we say that $\mathsf{ZFC}$ \emph{satisfies} $\mathsf{CH}$, written $\mathsf{ZFC} \models \mathsf{CH}$, if the interpretation of $\mathsf{CH}$ in any model of $\mathsf{ZFC}$ is true. Dually, it is easy to show that $\mathsf{ZFC} \not \models \mathsf{CH}$: one simply exhibits a model of $\mathsf{ZFC}$ where $\mathsf{CH}$ is false, and harder to show that $\mathsf{ZFC} \models \mathsf{CH}$, because one has to consider all possible models.

$\mathsf{ZFC}$ is a collection of first-order sentences in the language of a single binary predicate relation $\{\in\}$, used to axiomatize set theory. The continuum hypothesis can be written in this fashion as a first-order sentence $\mathsf{CH}$. A proof of $\mathsf{CH}$ is a finite list of deductions starting from $\mathsf{ZFC}$ and ending at $\mathsf{CH}$. % We write $\mathsf{ZFC} \vdash \mathsf{CH}$ to indicate that there is a proof of $\mathsf{CH}$. 
The soundness theorem says that provability implies satisfiability, i.e. if $\mathsf{ZFC} \vdash \mathsf{CH}$, then $\mathsf{CH}$ interpreted in any model of $\mathsf{ZFC}$ is true. Taking the contrapositive, we can demonstrate the unprovability (equivalently, the consistency of the negation) of $\mathsf{CH}$ by exhibiting a single model where $\mathsf{CH}$ is not true.

A model of a first-order theory $T$ in a language $L$ is in particular a way of assigning $\mathsf{true}$ or $\mathsf{false}$ in a coherent way to sentences in $L$. Modulo provable equivalence, the sentences form a Boolean algebra and ``coherent'' means the assignment is a Boolean algebra homomorphism (so $\land$ becomes meet, $\lor$ becomes join, $\forall$ becomes an indexed infimum, etc.) into $\mathbf{2} = \{\mathsf{true}, \mathsf{false}\}$. The soundness theorem ensures that this homomorphism $v$ sends a proof $\phi \vdash \psi$ to an inequality $v(\phi) \leq v(\psi)$. But $\mathbf{2}$ does not really play a special role in this scheme, and may be replaced by any complete Boolean algebra $\B$, where the top and bottom elements $\top, \bot$ take the place of $\mathsf{true}$ and $\mathsf{false}$. It is straightforward to extend this analogy to a $\B$-valued semantics for first-order logic, and in this generality, the soundness theorem now says that for any such $\B$, if $\mathsf{ZFC} \vdash \mathsf{CH}$, then for any $\B$-valued structure where all the axioms of $\mathsf{ZFC}$ have truth-value $\top$, $\mathsf{CH}$ does also. Then as before, to demonstrate the consistency of the negation of $\mathsf{CH}$ it suffices to find just one $\mathbb{B}$ and a single $\mathbb{B}$-valued model where $\mathsf{CH}$ is not ``true''.

This is where forcing comes in. Given a universe $V$ of set theory which contains a Boolean algebra $\B$, one constructs in analogy to the cumulative hierarchy a new $\B$-valued universe $V^\B$ of set theory, where the powerset operation is replaced by taking functions into $\B$. Thus, the structure of $\B$ informs the decisions made by $V^\B$ about what subsets, hence functions, exist among the members of $V^\B$; the real challenge lies in selecting a suitable $\B$ and reasoning about how its structure affects the structure of $V^\B$. While $V^\B$ may vary wildly depending on the choice of $\B$, the original universe $V$ always embeds into $V^\B$ via an operation $x \mapsto \check{x}$, and while the passage of $x$ to $\check{x}$ may not always preserve its original properties, $\Delta_0$-properties are always preserved; in particular, $V^\B$ thinks $\check{\mathbb{N}}$ is $\mathbb{N}$.

To force the negation of the continuum hypothesis, we use the Boolean algebra of regular opens of the Cantor space $\B := \operatorname{RO}(2^{\aleph_2 \times \mathbb{N}})$. For each $\nu \in \aleph_2$, we associate the $\B$-valued characteristic function $\chi_\nu : \mathbb{N} \to \B$ by $n \mapsto \{f \operatorname{|} f(\nu, n) = 1\}$. This induces what $V^\B$ thinks is a new subset $\widetilde{\chi_{\nu}} \subseteq \mathbb{N}$, called a \emph{Cohen real}, and furthermore induces what $V^\B$ thinks is a function from $\check{\aleph_2} \to \mathcal{P}(\mathbb{N})$. After showing that $V^\B$ thinks this function is injective, to finish the proof it suffices to show that $x \mapsto \check{x}$ preserves cardinal inequalities, as then we will have squeezed $\check{\aleph_1}$ properly between $\mathbb{N}$ and $\mathcal{P}(\mathbb{N})$. This is really the technical heart of the matter, and centers on a combinatorial property of $\B$ called the \emph{countable chain condition} (CCC), the proof of which requires a detailed combinatorial analysis of the basis of the product topology for $2^{\aleph_2 \times \mathbb{N}}$.

So far we have mentioned nothing about how this argument, which is wholly set-theoretic, is to be interpreted inside type theory. To do this, it was important for us to separate the mathematical content from the metamathematical content of the argument. Traditional presentations of forcing are careful to stay within the circle of ZFC, and it is not immediately clear what parts of the argument use that set-theoretic foundation in an essential way, e.g. if to perform forcing one must have ordinals that look like von Neumann ordinals in the metatheory, or if one must take a model of set theory as the starting point, or if $\B$ must be internal to a model of set theory... As we will see, our formalization will clarify some of these questions.

Finally, we remark that for working with Boolean-valued models, It is profitable to keep in mind the following analogy, developed by Scott in \cite{scott1}. A ready supply of complete Boolean algebras $\B$ is obtained by taking the measure algebra of a probability space and quotienting by the ideal of events of measure zero. Let $\mathbf{M}$ be a $\B$-valued structure. A unary $\B$-valued predicate $\phi$ on $\mathbf{M}$ assigns an event to every element $m$ of $\mathbf{M}$, whose measure we can think of as being the probability that $\phi(m)$ is true. Specializing to the language of set theory, we can attach to every $m : \mathbf{M}$ an ``indicator function'' $\lambda x, x \in m$ which assigns to every $x$ a probability that it is actually a member of $m$. Thus, by virtue of extensionality, we may think of the elements of a $\B$-valued model of ZFC as being ``set-valued random variables'', or ``random sets''.\footnote{In this analogy, given a universe of random sets, the purpose of the generic filter or ultrafilter in forcing is then to simultaneously evaluate the outcomes of the random variables, collapsing them into an ordinary universe of sets.} We refer the interested reader to \cite{scott1} and \cite{moore1} for details.

\paragraph*{Sources}
Our strategy for constructing a Boolean-valued model in which the continuum hypothesis fails is a synthesis of the proofs in the textbooks of Bell (\cite{bell1}, Chapter 2) and Manin (\cite{manin1}, Chapter 8). For the $\Delta$-system lemma, which is required for the countable chain condition, we followed Kunen (\cite{kunen1}, Chapters 1 and 5).

\paragraph*{Viewing the formalization}
The source code for our formalization is available at \url{https://github.com/flypitch/flypitch}. The forcing argument for the negation of CH is located in \lstinline{forcing.lean}. In a Lean-aware editor such as Emacs, the user is encouraged start at the theorem \lstinline{neg_CH} and jump backwards to trace the dependencies of the proof. (TODO(jesse) maybe change this to point at the ``summary'' file)
\section{First-order logic}
\label{sect:fol}
The starting point for first-order logic is a \emph{language} of relation and function symbols. We represent a language as a pair of $\N$-indexed families of types, each of which is to be thought of as the collection of relation (resp. function) symbols, but stratified by arity.

\begin{lstlisting}
structure Language : Type (u+1) :=
(functions : ‚Ñï ‚Üí Type u) (relations : ‚Ñï ‚Üí Type u)
\end{lstlisting}

\subsection{(Pre)terms, (pre)formulas}
% /- preterm L l is a partially applied term. if applied to n terms, it becomes a term.
% * Every element of preterm L 0 is a well-formed term.
% * We use this encoding to avoid mutual or nested inductive types, since those are not too convenient to work with in Lean. -/
TODO(floris) convert docstring into english

\begin{lstlisting}
inductive preterm : ‚Ñï ‚Üí Type u
| var {} : ‚àÄ (k : ‚Ñï), preterm 0
| func : ‚àÄ {l : ‚Ñï} (f : L.functions l), preterm l
| app : ‚àÄ {l : ‚Ñï} (t : preterm (l + 1)) (s : preterm 0), preterm l
\end{lstlisting}

TODO(floris) convert docstring into english
% preformula l is a partially applied formula. if applied to n terms, it becomes a formula.
%   * We only have implication as binary connective. Since we use classical logic, we can define
%     the other connectives from implication and falsum.
%   * Similarly, universal quantification is our only quantifier.
%   * We could make `falsum` and `equal` into elements of rel. However, if we do that, then we cannot make the interpretation of them in a model definitionally what we want.

\begin{lstlisting}
inductive preformula : ‚Ñï ‚Üí Type u
| falsum {} : preformula 0
| equal (t‚ÇÅ t‚ÇÇ : term L) : preformula 0
| rel {l : ‚Ñï} (R : L.relations l) : preformula l
| apprel {l : ‚Ñï} (f : preformula (l + 1)) (t : term L) : preformula l
| imp (f‚ÇÅ f‚ÇÇ : preformula 0) : preformula 0
| all (f : preformula 0) : preformula 0
\end{lstlisting}

TODO(floris) convert docstring into english

%   /- Provability
% * to decide: should Œì be a list or a set (or finset)?
% * We use natural deduction as our deduction system, since that is most convenient to work with.
% * All rules are motivated to work well with backwards reasoning.
% -/

\begin{lstlisting}
inductive prf : set (formula L) ‚Üí formula L ‚Üí Type u
| axm     {Œì A} (h : A ‚àà Œì) : prf Œì A
| impI    {Œì : set (formula L)} {A B} (h : prf (insert A Œì) B) : prf Œì (A ‚üπ B)
| impE    {Œì} (A) {B} (h‚ÇÅ : prf Œì (A ‚üπ B)) (h‚ÇÇ : prf Œì A) : prf Œì B
| falsumE {Œì : set (formula L)} {A} (h : prf (insert ‚àºA Œì) ‚ä•) : prf Œì A
| allI    {Œì A} (h : prf (lift_formula1 '' Œì) A) : prf Œì (‚àÄ' A)
| allE‚ÇÇ   {Œì} A t (h : prf Œì (‚àÄ' A)) : prf Œì (A[t // 0])
| ref     (Œì t) : prf Œì (t ‚âÉ t)
| subst‚ÇÇ  {Œì} (s t f) (h‚ÇÅ : prf Œì (s ‚âÉ t)) (h‚ÇÇ : prf Œì (f[s // 0])) : prf Œì (f[t // 0])
\end{lstlisting}

\subsection{Completeness}
As part of our formalization of first-order logic, we completed a verification of the G\"odel completeness theorem. Although our present development of forcing did not require it, we anticipate that it will required later to e.g. prove the downward L\"owenheim-Skolem theorem to extract countable transitive models for forcing with generic extensions; also, like the soundness theorem, it serves as a proof-of-concept and a stress-test of our chosen encoding of first-order logic.

For our formalization, we chose the Henkin-style approach of constructing a canonical term model. In order to perform the argument, which normally involves modifying the language ``in place'' to iteratively add new constant symbols, we had to adapt it to type theory. Since our languages are represented by pairs of indexed types instead of sets, we cannot really modify them in-place with new constant symbols. Instead, at each step of the construction, we must construct an entirely new language, in which the previous one embeds as a subtype, and in the limit, we cannot take a union, but must rather compute a directed colimit of types. This directed colimit of languages induce similar constructions on preterms, preformulas, sentences, and so on, and completing the argument requires reasoning with all of them. However, our proof was made significantly easier by our design decisions: only a few arguments required anything more than straightforward case-analysis and structural induction.

Here is one notable exception. In the process of our formalization, we discovered a nontrivial hole in many presentations of the Henkin argument (TODO(floris) describe \lstinline{reflect_prf})

We remark that our formalization of the completeness theorem is as general as possible, making no assumptions on the cardinality of the language or the presence of function symbols.

\subsection{(Boolean-valued) soundness}
\subsection{Boolean-valued semantics for first-order logic}

A \textbf{complete Boolean algebra} is a type $\B$ equipped with the structure of a Boolean algebra and additionally operations $\operatorname{Inf}$ and $\operatorname{Sup}$ (which we write as $\bigsqcap$ and $\bigsqcup$) returning the infimum and supremum of an arbitrary collection of members of $\B$. For more details on complete Boolean algebras, we refer the reader to the textbook of Halmos-Givant \cite{halmos-givant1}.

\begin{definition}\label{def-boolean-valued-structure}
  A Boolean-valued structure is...
\end{definition}

Note that Boolean-valued equality is not really an equivalence relation. One complication which then arises in Boolean-valued semantics is keeping track of the extensionality proofs for formulas. However, as part of the Soundness theorem shows, once these extensionality proofs are provided for the basic symbols in the language, they extend by structural induction to all formulas.

\subsection{The soundness theorem}

A soundness theorem says that a proof tree may be replayed to produce an actual proof in the object of truth-values. When the object is truth-values is the type \texttt{Prop} of propositions, this says that a proof tree compiles to a proof term. When the object of truth-values is a Boolean algebra, this says that the proof tree becomes an internal implication from the interpretation of the context to the interpretation of the conclusion.

We designed our datatype of proofs as an inductive type whose constructors are precisely the natural deduction rules naturally supported by Lean's Prop. As a result, the proofs of either soundness theorem become straightforward structural inductions.

%% TODO(floris) elaborate a bit

\section{Constructing Boolean-valued models of set theory}
\label{sect:bvm}
Throughout this section, we fix a universe level $u$, a type \lstinline{ùîπ : Type u} and an instance of a complete Boolean algebra structure on $\B$.

In set theory (see e.g. Jech \cite{jech1} or Bell \cite{bell1}), Boolean-valued models are obtained by imitating the construction of the von Neumann cumulative hierarchy via a transfinite recursion where iterations of the powerset operation (taking functions into $\mathbf{2} = \{\operatorname{true}, \operatorname{false}\}$) are replaced by iterations of the ``\lstinline{ùîπ}-valued powerset operation'' (taking functions into $\B$).

Since this construction by transfinite recursion does not easily translate into type theory, our construction of Boolean-valued models of set theory is instead a variation on a well-known encoding originally due to Aczel \cite{aczel1} \cite{aczel2} \cite{aczel3}. This encoding was adapted by Werner \cite{werner1} to encode ZFC into Coq, whose metatheory is close to that of Lean. Werner's construction was re-implemented in Lean's \texttt{mathlib} by Carneiro as part of \cite{mario1}. In this approach, one takes a universe of types \texttt{Type u} as the starting point and then imitates the cumulative hierarchy by constructing the inductive type
\begin{lstlisting}
inductive pSet : Type (u+1)
| mk (Œ± : Type u) (A : Œ± ‚Üí pSet) : pSet
\end{lstlisting}
(Just as the empty set kicks off the construction of the cumulative hierarchy, the empty type admits an empty map into any type and so induces \lstinline{‚àÖ : pSet}.)

The Aczel-Werner encoding is closely related to the recursive definition of \emph{names} in forcing:

\begin{definition}\label{def-p-name}
Let $P$ be a partial order (which one thinks of as a collection of forcing conditions). A \emph{$P$-name} is a collection of pairs $(y, p)$ where $y$ is a $P$-name and $p : P$.
\end{definition}

 If $P$ consists of only one element, then a $P$-name is specified by essentially the same information as a member of the inductive type \lstinline{pSet} above. Conversely, specializing $P$ to an arbitrary complete Boolean algebra $\B$, we modify the definition of \lstinline{pSet.mk} so that elements are recursively assigned Boolean truth-values:
\begin{lstlisting}
inductive bSet (ùîπ : Type u) [complete_boolean_algebra ùîπ] : Type (u+1)
| mk (Œ± : Type u) (A : Œ± ‚Üí bSet) (B : Œ± ‚Üí ùîπ) : bSet
\end{lstlisting}
Thus \lil{bSet ùîπ} is the type of $\B$-names, and will be the underlying type of our Boolean-valued model of set theory.

\subsection{Boolean-valued equality and membership}
% In order to view \lil{bSet ùîπ} as a Boolean-valued structure, we must first equip it with a Boolean-valued notion of equality. In models of set theory, the axiom of extensionality ensures that the notions of \lil{=}, \lil{‚àà}, and \lil{‚äÜ} are tightly connected, and in fact, in every reference we found, \lil{=} and \lil{‚àà} were defined simultaneously using mutual recursion. Although this makes checking e.g. the axiom of extensionality a matter of definition, we found this was unnecessary, and avoid the mutually recursive definition by making equality the primitive notion.

In \lil{pSet}, equivalence of sets is defined by structural recursion as follows: two sets $x$ and $y$ are equivalent if and only if for every $w \in x$, there exists a $w' \in y$ such that $w$ is equivalent to $w'$, and vice-versa. Analogously, by translating quantifiers and connectives into operations on $\B$, Boolean-valued equality is defined in the same way:
\begin{lstlisting}
def bv_eq : ‚àÄ (x y : bSet ùîπ), ùîπ
| ‚ü®Œ±, A, B‚ü© ‚ü®Œ±', A', B'‚ü© :=
             (‚®Öa : Œ±, B a ‚üπ ‚®Üa', B' a' ‚äì bv_eq (A a) (A' a')) ‚äì
               (‚®Öa' : Œ±', B' a' ‚üπ ‚®Üa, B a ‚äì bv_eq (A a) (A' a'))
\end{lstlisting}

We abbreviate \lil{bv_eq} with the infix operator \lil{=·¥Æ}. With equality is place, it is easy to define membership, by translating ``$x$ is a member of $y$ if and only if there exists a $w \in y$ such that $x = w$.'' As with equality, we denote $\B$-valued membership with \lil{‚àà·¥Æ}.
             
\begin{lstlisting}
def mem : bSet ùîπ ‚Üí bSet ùîπ ‚Üí ùîπ
| a (mk Œ±' A' B') := ‚®Üa', B' a' ‚äì a =·¥Æ A' a'
\end{lstlisting}

\subsection{Reasoning in $\B$}
As Scott stresses in \cite{scott3}, ``A main point ... is that the well-known algebraic characterizations of [complete Heyting algebras] and [complete Boolean algebras] exactly mimic the rules of deduction in the respective logics\ldots{}'' Indeed, that is really why the Boolean-valued soundness theorem is true. One thinks of the \lil{‚â§} symbol in an inequality of Boolean truth-values as a turnstile in a proof state: the conjunctands on the left as a list of assumptions in context, and the quantity on the right as the goal. For example, given \lil{a b : ùîπ}, the identity $(a \Rightarrow b) \sqcap a \leq b$ could be proven by unfolding the definition of material implication, but it is really just the natural deduction rule of implication elimination; similarly, given an indexed family \lil{a : I ‚Üí ùîπ}, \lstinline{‚®Üi, a i ‚â§ b ‚Üî ‚àÄ i, a i ‚â§ b} is just casing on an existential quantifier.

Where the difficulty arises with having only a basic library of lemmas like the ones above is when the statements one wants to prove become not even nontrivial, but only slightly more complicated. Consider the following example, which should be  ``\lil{by assumption}'':
\begin{lstlisting}
  ‚àÄ a b c d e f g: ùîπ, (d ‚äì e) ‚äì (f ‚äì g ‚äì ((b ‚äì a) ‚äì c)) ‚â§ a
\end{lstlisting}
or slightly less trivially, the following example where the goal is attainable by ``just applying a hypothesis to an assumption''
\begin{lstlisting}
  ‚àÄ a b c d : ùîπ, (a ‚üπ b) ‚äì c ‚äì (d ‚äì a) ‚â§ b
\end{lstlisting}

There are three ways to deal with goals like these, which approximately describe the evolution of our approach. First, one can try using the basic lemmas in \lil{mathlib}, using the simplifier to normalize expressions, and performing clever rewrites with the deduction theorem\footnote{The deduction theorem in a Boolean algebra says that for all $a, b$ and $c$, $a \sqcap b \leq c \iff a \leq b \Rightarrow c$.}. Second, one can take the LCF-style approach and expand the library of lemmas with increasingly sophisticated derived inference rules.

Third, one can make the following observation:

\begin{lemma}\label{poset-yoneda}
  Let $(P, \leq)$ be a partially ordered set. Let $a \hspace{1mm} b : P$. Then $a \leq b$ if and only if $\forall \Gamma : P, \Gamma \leq a \to \Gamma \leq b$.
\end{lemma}
This is an instance of the Yoneda lemma for partially ordered sets, and its proof is utterly trivial. However, one side of the equivalence is much easier for Lean to reason with. Take the example which should have been ``\lil{by assumption}''. The following proof, in which the user navigates down the binary tree of nested \lil{‚äì}s, will work:
\begin{lstlisting}
example {a b c d e f g : ùîπ} : (d ‚äì e) ‚äì (f ‚äì g ‚äì((b ‚äì a)‚äì c)) ‚â§ a :=
by {apply inf_le_right_of_le, apply inf_le_right_of_le,
    apply inf_le_left_of_le, apply inf_le_right_of_le, refl}
\end{lstlisting}

But if we use the right-hand side of \autoref{poset-yoneda} instead, then after some preprocessing, \lstinline{assumption} will literally work:

\begin{lstlisting}
example {a b c d e f g : ùîπ} : (d ‚äì e) ‚äì (f ‚äì g ‚äì((b ‚äì a)‚äì c)) ‚â§ a :=
by {apply poset_yoneda, intros Œì H, simp only [le_inf_iff] at H,
  repeat{auto_cases}, assumption}
/- Goal state before `assumption`:
H_left_left : Œì ‚â§ d,
H_left_right : Œì ‚â§ e,
H_right_right_right : Œì ‚â§ c,
H_right_left_left : Œì ‚â§ f,
H_right_left_right : Œì ‚â§ g,
H_right_right_left_left : Œì ‚â§ b,
H_right_right_left_right : Œì ‚â§ a
‚ä¢ Œì ‚â§ a -/
\end{lstlisting}

\subsubsection{Automation and metaprogramming}
A key feature of Lean is that it is its own metalanguage, allowing for seamless in-line definitions of custom tactics. This feature was an invaluable asset, as it allowed the rapid development of a custom tactic library for simulating natural-deduction style proofs inside $\B$ after applying \autoref{poset-yoneda} to insert a slack context variable \lil{Œì}. The preprocessing steps before the call to \lil{assumption} in the previous example are bundled into a single tactic \lil{tidy_context}, and Boolean-valued versions of basic niceties like or-elimination, instantiation of existentials, implication introduction, and even basic automation were easy to write and considerably streamlines the formalization workflow, to the point where the user is able to pretend, with absolute rigor, that they are simply writing proofs in first-order logic while calculations in the complete Boolean algebra are being performed under the hood. \textbf{TODO(jesse) wording}

One use-case where automation is crucial is context-specialization (``change of variables''). For example, if, after preprocessing with \lstinline{poset_yoneda}, the goal is \lstinline{Œì ‚â§ a ‚üπ b}, and one would like to ``introduce the implication'', by adding \lstinline{Œì ‚â§ a} to context and reducing the goal to \lstinline{Œì ‚â§ b}, this is impossible as stated. Rather, the deduction theorem lets us rewrite the goal to \lstinline{Œì ‚äì a ‚â§ b}, and now we may add \lstinline{Œì ‚äì a ‚â§ a}. So we may introduce the implication after all, but at the cost of specializing the context \lstinline{Œì} to the smaller context \lstinline{Œì' := Œì ‚äì a}. But now, in order for the user to continue the pretense that they are merely doing first-order logic, this change of variables must be propagated to the rest of the assumptions which may still be of the form \lstinline{Œì ‚â§ _}---which is extremely tedious to do by hand, but easy to automate.

% (TODO(jesse) add something about how this is an instance of adapting the proof assistant to assimilate a mathematical style of argument, like in the Gonthier paper.)


% % We were also interested in whether the presence of a proof assistant would change the ``user experience'' of working with Boolean-valued models, for one possible complaint about forcing with Boolean-valued models is that calculating truth values inside a complete Boolean algebra is notationally cumbersome in practice. This was indeed our experience---until we adapted Lean's automation to perform much of the bookkeeping for us, to the point where the user is able to pretend, with absolute rigor, that they are simply writing proofs in predicate calculus while lattice operations are being performed under the hood.
% \subsubsection{Automating congruence lemmas with the simplifier}
% The simplifier is one of Lean 3's most sophisticated tools for automation, and is quite powerful when used correctly. It uses automatically-generated congruence lemmas to navigate under binders and perform rewrites using lemmas marked with the \lstinline{simp} attribute. Given the pivotal role which congruence lemmas have in \lstinline{simp}'s functionality, we consider it fitting that \lstinline{simp} allowed us to automate the proofs of the Boolean-valued congruence (sometimes confusingly called \emph{extensionality}) lemmas which are required to speak of a Boolean-valued predicate on a Boolean-valued structure.

% TODO %and also maybe delete, it's not that important. i have the feeling we'll have too much material for 15 pages

\subsection{Check-names}
% \textbf{TODO(jesse) emphasize how check-names are how cardinals and ordinals in the metatheory interact with notions of size internally}
From the definitions of \lil{pSet} and \lil{bSet}, one immediately sees that there is a canonical map \lil{check : pSet ‚Üí bSet ùîπ}, defined by
\begin{lstlisting}
def check : pSet ‚Üí bSet ùîπ
| ‚ü®Œ±,A‚ü© := ‚ü®Œ±, Œª a, check (A a), Œª a, ‚ä§‚ü©
\end{lstlisting}

That is, \lil{check} takes a \lil{pSet} and recursively attaches the Boolean truth-value $\top$ to all elements. We call members of the image of \lil{check} \emph{check-names}. These are also known as \emph{canonical names}, as they are the canonical representation of standard two-valued sets inside a Boolean-valued model of set theory.

One of the most important considerations in forcing is how cardinals and ordinals in the metatheory interact with cardinals and ordinals in the forcing extension. We will see later that after translating the entire forcing argument to type theory, the presence of \lstinline{pSet} is misleading. It is not the ordinals and cardinals inside \lstinline{pSet} which are of fundamental importance, but rather the ordinals and cardinals of Lean itself. The role of the check-names is not any less decisive, but is it clear that the check-names are merely the way in which the metatheory's cardinals and ordinals interact with that in the forcing extension. \lstinline{pSet} is not a prerequisite for studying \lstinline{bSet} or performing forcing, but only a convenient aid to organize information about the check-names.

\subsection{Transfinite induction}
\label{sec:org9e70de8}
In set theory, it is common to prove propositions via induction on an ordinal-valued rank function. In fact, this is how V\(^{\text{BB}}\) is typically constructed, by induction on the rank of sets in an existing universe of sets V. In Lean, this style of argument does not come for as free as, say, structural induction principles like $\in$-induction, which by virtue of the construction of bSet BB, \emph{is} the induction principle for that inductive type. However, an interface is available for well-founded recursion on well-founded relations, and a development of the theory of ordinals as equivalence-classes of well-ordered types is available in \texttt{mathlib}. There were two places in the present work where transfinite induction was unavoidable, namely in the construction of an antichain for the maximum principle, and the verification that the canonical embedding of ordinals into \texttt{pSet} is injective.

\subsection{The fundamental theorem of forcing}

The fundamental theorem of forcing for Boolean-valued models \cite{hamkins-seabold1} states that for any complete Boolean algebra $B$, $V^B$ is a Boolean-valued model of ZFC. Since, in type theory, a type universe \lstinline{Type u} takes the place of the standard universe $V$, the analogous statement in our setting is that for every complete Boolean algebra $\B$, \lstinline{bSet ùîπ} is a Boolean-valued model of ZFC.

After the development of the custom proof language,
\textbf{(TODO(jesse) add more definitions to ref to}
much of the verification of the axioms besides choice is routine, as the user is able to pretend they are working in ordinary 2-valued logic. We describe some aspects of \lil{bSet ùîπ} which are illuminated by the verification of the axioms and which will be important for forcing $\neg\mathsf{CH}$.

\paragraph*{The axiom of infinity}
$\omega$ \lil{: bSet ùîπ} is $\check{\omega}$. $\omega$ is defined in \lil{pSet} to be the collection of all finite von Neumann ordinals, which are defined by induction on $\mathbb{N}$. While it is easy to show $\check{\omega}$ satisfies the axiom of infinity
\begin{lstlisting}
def axiom_of_infinity_spec (u : bSet ùîπ) : ùîπ :=
  (‚àÖ‚àà·¥Æ u) ‚äì (‚®Öi_x, ‚®Üi_y, (u.func i_x ‚àà·¥Æ u.func i_y))
\end{lstlisting}
it can furthermore be shown to satisfy the universal property of $\omega$, which says that $\omega$ is a subset of any set which contains $\emptyset$ and is closed under the successor operation $x \mapsto x \cup {x}$.

\paragraph*{The axiom of powerset}
\begin{definition}
  Fix a $\B$-valued set \lil{x = ‚ü®Œ±, A, b‚ü©}. Let \lil{œá : Œ± ‚Üí ùîπ} be a function. The subset of \lil{x} associated to \lil{œá} is a \lil{ùîπ}-valued set defined as follows:
  \begin{lstlisting}
def set_of_indicator {x} (œá : x.type ‚Üí ùîπ) := ‚ü®x.type, x.func, œá‚ü©
\end{lstlisting}

The \textbf{powerset} $\mathcal{P}(x)$ of $x$ is defined to be the following \lil{ùîπ}-valued set, whose underlying type is the type of all functions \lil{x.type ‚Üí ùîπ}:
\begin{lstlisting}
def bv_powerset (u : bSet ùîπ) : bSet ùîπ :=
‚ü®u.type ‚Üí ùîπ, Œª f, set_of_indicator f, Œª f, set_of_indicator f ‚äÜ·¥Æ u‚ü©
\end{lstlisting}
\end{definition}

\paragraph*{The axiom of choice}
Following the presentation in Bell \cite{bell1}, we verified Zorn's lemma, which is provably equivalent over $\mathsf{ZF}$ to the axiom of choice. As is the case with \lil{pSet}, establishing the axiom of choice requires the use of a choice principle from the metatheory. This was the most involved part of our verification of the fundamental theorem of forcing, and relies on the technical tool of \emph{mixtures}, which allow sequences of $\B$-valued sets to be ``averaged'' into new ones, and the \emph{maximum principle}, which allows existentially quantified statements to be instantiated without changing their truth-value.

\paragraph*{The smallness of $\B$}
Before ending this section, we remark that the ``smallness'' (or more precisely, the fact that $\B$ lives in the same universe of types out of which \lil{bSet ùîπ} is being built), plays a crucial a role in making \lstinline{bSet ùîπ} a model of ZFC. It is required for extracting the witness needed for the maximum principle, and is also required to even define the powerset operation, because the underlying type of the powerset is the function type of all maps into \lstinline{ùîπ}.

\section{Forcing ¬¨CH}
\label{sect:forcing}
\subsection{The Cohen poset and the regular open algebra}
Forcing with partial orders and forcing with complete Boolean algebras are related by the fact that every poset of forcing conditions can be embedded into a complete Boolean algebra as a dense suborder. This will be the case for our forcing argument: our Boolean algebra is the algebra of regular opens on $2^{\aleph_2 \times \mathbb{N}}$, which embeds the poset of forcing conditions typically used for Cohen forcing as a dense suborder.

\begin{definition}
  The \textbf{Cohen poset} for adding $\aleph_2$-many Cohen reals is the collection of all finite partial functions $\aleph_2 \times \mathbb{N} \to \mathbf{2}$, ordered by reverse inclusion.
\end{definition}

In the formalization, the Cohen poset is represented as a \lstinline{structure} with three fields:
\begin{lstlisting}
structure ùíû : Type :=
  (ins : finset (‚Ñµ‚ÇÇ.type √ó ‚Ñï))
  (out : finset (‚Ñµ‚ÇÇ.type √ó ‚Ñï))
  (H : ins ‚à© out = ‚àÖ)
\end{lstlisting}

That is, we identify a finite partial function $f$ with the triple \lil{‚ü®f.ins, f.out, f.H‚ü©}, where \lil{f.ins} is the preimage of $\{1\}$, \lil{f.out} is the preimage of $\{0\}$, and \lil{f.H} ensures well-definedness. While $f$ is usually defined as a finite partial function, we found that in practice (that is, in proofs) $f$ is really needed to give a finite partial specification of a subset of $\aleph_2 \times \mathbb{N}$ (i.e. a finite set \lil{ins} which \emph{must} be in the subset, and a finite set \lil{out} which \emph{must not} be in the subset), and chose this representation to make that information immediately accessible.

\begin{definition}
  Let $X$ be a topological space, and for any open set $U$, let $U^\perp$ denote the complement of the closure of $U$. The \textbf{regular open algebra} of a topological space $X$, written $\operatorname{RO}(X)$, is the collection of all open sets $U$ such that $U = (U^\perp)^\perp$, equipped with the structure of a complete Boolean algebra, with $x \sqcap y := x \cap y$, $x \sqcup y := ((x \sqcup y)^\perp)^\perp$, $\neg x := x^\perp$, and $\bigsqcup x_i := ((\bigcup x_i)^\perp)^\perp$.
\end{definition}

The Boolean algebra which we will use for forcing $\neg\mathsf{CH}$ is $\operatorname{RO}(2^{\aleph_2 \times \mathbb{N}})$. For the rest of this section, we put $\B := \operatorname{RO}(2^{\aleph_2 \times \mathbb{N}})$.

\begin{definition}
  We define the \textbf{canonical embedding} of the Cohen poset into $\B$ as follows:
  \begin{lstlisting}
def Œπ : ùíû ‚Üí ùîπ := Œª p, {S | p.ins ‚äÜ S ‚àß p.out ‚äÜ - S}    
\end{lstlisting}
\end{definition}
That is, we send each \lil{c : ùíû} all the subsets which satisfy the specification given by \lil{c}. This is a clopen set, hence regular.

Crucially, this embedding is \emph{dense}: 

\subsection{Adding $\omega_2$-many distinct Cohen reals}

\subsection{Preservation of cardinal inequalities}

\section{Transfinite combinatorics and the countable chain condition}
\label{sect:ccc}

\subsection{The $\Delta$-system lemma}

\subsection{The countable chain condition}

\section{Future work}

\subsection{Applications of Boolean-valued semantics}

(maybe remove? fill this out if you have time.)
\subsection{Proof by reflection}

Combined with the usual completeness theorem, the Boolean-valued soundness theorem will allow us to prove statements about a structure of the form bSet BB as follows: if the statement $\phi$ is provable from ZF, then we may prove that ZF proves $\phi$ by applying the completeness theorem to reason inside an arbitrary model of ZF. This avoids the complications of trying to work directly inside Boolean-valued logic. Then, given a Boolean-valued L\(_{\text{ZFC}}\)-structure $\mathbf{M}$ which satisfies ZF, the Boolean-valued soundness theorem tells us that this proof may be replayed inside $\mathbf{M}$ so that $\phi$ has truth-value greater than the truth-values of ZF, and is therefore satisfied inside $\mathbf{M}$.

In this way, we can transport proofs of statements such as "Zorn's lemma is equivalent to the axiom of choice", which is provable from ZF, directly from the world of 2-valued models to the world of Boolean-valued models.

We also remark that while our use of \texttt{simp} lemmas to generate congruence certificates sufficed for the purposes of this work, the "real" proof that something like the subset predicate is $=^B$-extensional is a proof by reflection: one constructs a formula which reifies the predicate, and then applies the fact that one is in the deeply-embedded Boolean-valued structure to obtain the congruence lemma automatically. We also intend to automate this.
\subsection{Forcing with generic models}

Our method does not support iterated forcing. Our method starts with a universe of types and uses that to construct a model of set theory.
\subsection{Towards a formal proof of the independence of the continuum hypothesis}


This work was carried out as part of the Flypitch project, which aims to formalize the independence of the continuum hypothesis from ZFC, i.e. that CH and its negation are both unprovable from the ZFC axioms.

Future goals of the project include:

\begin{itemize}
\item Various formulations of the axioms of ZFC are equiconsistent, including the versions used in this paper
\end{itemize}
\section{Conclusions and future work}

\begin{itemize}
\item In order to complete this formalization, we had to develop several libraries, e.g. for dependently-typed vectors, significant extensions of the lattice and Boolean algebra library, the theory of product topological space and their bases, and extensions to the set theory and ordinal libraries.
  
\item \texttt{pSet} was not essential. Rather, in our type-theoretic foundations, the construction of a Boolean-valued standard universe of set theory has equal footing with the construction of an ordinary standard universe of set theory. We see that for the purposes of working with V\(^{\text{BB}}\), V is no longer a prerequisite, but merely a useful tool for organizing the check-names.
\item We used several features of our type-theoretic foundations to our advantage. We constructed a standard universe of set theory structurally in such a way that many properties of the underlying universe of types are reflected inside the model of set theory, and such that we get the axiom of regularity (more precisely, the principle of epsilon-induction) for free as the automatically-generated induction principle for our inductive type.
\item Lean is great, meteoric growth --- remark on recentness of developments in \texttt{mathlib} which made this possible (acknowledge developments from other theorem-provers, including porting of libraries e.g. \texttt{lattice} from Isabelle).
\item Evidence that formalized mathematics is ready "in the large"
\end{itemize}

\section{References}
\begin{itemize}
\item Moore's The method of forcing
\item Halmos-Givant Textbook on boolean algebras
\item Gunther Pagano et al forcing in Isabelle/ZF
\item Paulson constructible universe and set theory in Isabelle/ZF
\item Sets in Coq, Coq in Sets
\item Sets in types, types in sets
\item Aczel's encoding of ZFC inside type theory
\end{itemize}

\end{document}